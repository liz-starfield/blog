import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as r,c as e,e as i}from"./app-E1ZDnjkm.js";const d="/blog/assets/1.数组-1-7fAv5dnT.png",t={},s=i('<h1 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h1><h2 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h2><ol><li>属于线性表 <br></li></ol><p>线性表，只有前后两个方向：数组、链表、栈、队列 <br> 非线性表：树、图 <br></p><ol start="2"><li>连续的内存空间和相同类型的数据 <br></li><li>优：随机访问O(1) <br></li></ol><p>随机访问是指通过下标访问。 <br> 查找 != 随机访问，即便是排好序的用二分查找，时间复杂度为O(logn)） <br></p><ol start="4"><li>缺：增删元素要做大量的数据搬移工作(O(n) <br></li></ol><p>低效，可以改进吗？如果不必保证原有顺序，那可以！ <br></p><h2 id="如何做到随机访问-一维数组的内存寻址公式" tabindex="-1"><a class="header-anchor" href="#如何做到随机访问-一维数组的内存寻址公式" aria-hidden="true">#</a> 如何做到随机访问：一维数组的内存寻址公式</h2><p>a[i]_address = base_address + i * data_type_size <br> 为什么很多编程语言中数组都从0开始编号，而不是从1开始？ <br> 数组下标从0开始，下标代表着偏移量，如果从1开始计数，内存寻址公式要改为a[i]_address = base_address + （i-1） * data_type_size，每次访问数组多了一次减法运算。 <br></p><h2 id="改进低效插入-应用-快排" tabindex="-1"><a class="header-anchor" href="#改进低效插入-应用-快排" aria-hidden="true">#</a> 改进低效插入（应用：快排）</h2><p>在第k位插入元素，直接把原先第k位元素放到最后，把新元素插入第k位。 <br> 时间复杂度就从O(n)降到O(1)。 <br> 这个处理思想在快排中有用到。 <br></p><h2 id="改进低效删除-应用-jvm的标记清除垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#改进低效删除-应用-jvm的标记清除垃圾回收算法" aria-hidden="true">#</a> 改进低效删除（应用：JVM的标记清除垃圾回收算法）</h2><p><img src="'+d+'" alt="image.png" loading="lazy"> <br> 为了避免d,e,f,g,h这几个数据会被搬移三次，我们可以先记录下已经删除的数据。 每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。 <br> 这就是 JVM 标记清除垃圾回收算法的核心思想。 <br></p><h2 id="容器能否完全替代数组" tabindex="-1"><a class="header-anchor" href="#容器能否完全替代数组" aria-hidden="true">#</a> 容器能否完全替代数组？</h2><h3 id="arraylist优势" tabindex="-1"><a class="header-anchor" href="#arraylist优势" aria-hidden="true">#</a> ArrayList优势</h3><ol><li>将很多数组操作的细节封装起来（eg. 数组插入、删除数据时需要搬移其他数据等） <br></li><li>支持动态扩容（每次存储空间不够，会将空间自动扩容1.5倍大小） <br> Note： 因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以， 如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小， 事先指定数据大小可以省掉很多次内存申请和数据搬移操作。 <br></li></ol><h3 id="用数组更适合的情况" tabindex="-1"><a class="header-anchor" href="#用数组更适合的情况" aria-hidden="true">#</a> 用数组更适合的情况</h3><ol><li>使用基本类型又特别关注性能（ArrayList只能存包装类， 而 Autoboxing、Unboxing 则有一定的性能消耗） <br></li><li>多维数组，用数组更直观 <br></li><li>大小事先已知且操作简单 <br></li></ol>',19),h=[s];function l(n,o){return r(),e("div",null,h)}const _=a(t,[["render",l],["__file","1.数组.html.vue"]]);export{_ as default};
