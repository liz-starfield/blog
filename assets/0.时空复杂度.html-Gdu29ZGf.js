const e=JSON.parse('{"key":"v-2891a61a","path":"/zh/posts/code/algorithm/0.%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6.html","title":"复杂度分析 Complexity Analysis","lang":"zh-CN","frontmatter":{"icon":"lightbulb","description":"复杂度分析 Complexity Analysis 1. 大O复杂度表示法 T(n) = O(f(n)) T(n)表示代码执行时间 n表示数据规模大小 f(n)表示每行代码执行次数总和 表示代码执行时间/所需空间随数据规模增长的变化趋势。 Note：只是表示一种变化趋势，不是具体的执行时间/空间大小。低阶、常量、系数被忽略，只记录最大量级就可以了。 2. 复杂度计算 最大值法则（非嵌套代码）：总复杂度等于量级最大的那段代码的复杂度","head":[["link",{"rel":"alternate","hreflang":"en-us","href":"https://liz-starfield.github.io/blog/posts/code/algorithm/0.%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6.html"}],["meta",{"property":"og:url","content":"https://liz-starfield.github.io/blog/zh/posts/code/algorithm/0.%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6.html"}],["meta",{"property":"og:site_name","content":"莉芝"}],["meta",{"property":"og:title","content":"复杂度分析 Complexity Analysis"}],["meta",{"property":"og:description","content":"复杂度分析 Complexity Analysis 1. 大O复杂度表示法 T(n) = O(f(n)) T(n)表示代码执行时间 n表示数据规模大小 f(n)表示每行代码执行次数总和 表示代码执行时间/所需空间随数据规模增长的变化趋势。 Note：只是表示一种变化趋势，不是具体的执行时间/空间大小。低阶、常量、系数被忽略，只记录最大量级就可以了。 2. 复杂度计算 最大值法则（非嵌套代码）：总复杂度等于量级最大的那段代码的复杂度"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-10-16T06:02:20.000Z"}],["meta",{"property":"article:author","content":"Liz"}],["meta",{"property":"article:modified_time","content":"2024-10-16T06:02:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"复杂度分析 Complexity Analysis\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-16T06:02:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Liz\\",\\"url\\":\\"https://github.com/liz-starfield\\"}]}"]]},"headers":[{"level":2,"title":"1. 大O复杂度表示法","slug":"_1-大o复杂度表示法","link":"#_1-大o复杂度表示法","children":[]},{"level":2,"title":"2. 复杂度计算","slug":"_2-复杂度计算","link":"#_2-复杂度计算","children":[]},{"level":2,"title":"3. 复杂度量级","slug":"_3-复杂度量级","link":"#_3-复杂度量级","children":[]},{"level":2,"title":"4. 通用数据结构复杂度","slug":"_4-通用数据结构复杂度","link":"#_4-通用数据结构复杂度","children":[]},{"level":2,"title":"5. 递归复杂度分析","slug":"_5-递归复杂度分析","link":"#_5-递归复杂度分析","children":[{"level":3,"title":"5.1. 迭代法（一般不用此，用下面的公式法了）","slug":"_5-1-迭代法-一般不用此-用下面的公式法了","link":"#_5-1-迭代法-一般不用此-用下面的公式法了","children":[]}]},{"level":2,"title":"5.2. 公式法（最便捷）","slug":"_5-2-公式法-最便捷","link":"#_5-2-公式法-最便捷","children":[{"level":3,"title":"5.3. 递归树：借助递归树来分析递归算法的时间复杂度","slug":"_5-3-递归树-借助递归树来分析递归算法的时间复杂度","link":"#_5-3-递归树-借助递归树来分析递归算法的时间复杂度","children":[]},{"level":3,"title":"5.3.3. 递归树分析斐波那契数列","slug":"_5-3-3-递归树分析斐波那契数列","link":"#_5-3-3-递归树分析斐波那契数列","children":[]},{"level":3,"title":"5.3.4. 递归树分析全排列","slug":"_5-3-4-递归树分析全排列","link":"#_5-3-4-递归树分析全排列","children":[]}]}],"git":{"createdTime":1729058540000,"updatedTime":1729058540000,"contributors":[{"name":"unknown","email":"15721607377@163.com","commits":1}]},"readingTime":{"minutes":5.63,"words":1690},"filePathRelative":"zh/posts/code/algorithm/0.时空复杂度.md","localizedDate":"2024年10月16日","excerpt":"<h1> 复杂度分析 Complexity Analysis</h1>\\n<h2> 1. 大O复杂度表示法</h2>\\n<p>T(n) = O(f(n))</p>\\n<ul>\\n<li>T(n)表示代码执行时间</li>\\n<li>n表示数据规模大小</li>\\n<li>f(n)表示每行代码执行次数总和</li>\\n</ul>\\n<p>表示代码执行时间/所需空间随数据规模增长的变化趋势。</p>\\n<p>Note：只是表示一种变化趋势，不是具体的执行时间/空间大小。低阶、常量、系数被忽略，只记录最大量级就可以了。</p>\\n<h2> 2. 复杂度计算</h2>\\n<ol>\\n<li>最大值法则（非嵌套代码）：总复杂度等于量级最大的那段代码的复杂度 <br></li>\\n</ol>","autoDesc":true}');export{e as data};
