const e=JSON.parse('{"key":"v-17990ded","path":"/zh/posts/code/data_structure/2.%E9%93%BE%E8%A1%A8.html","title":"链表","lang":"zh-CN","frontmatter":{"icon":"lightbulb","description":"链表 链表分类 单链表 每个结点由两部分组成，data和next。 特殊结点：头结点、尾结点 头结点：第一个结点，用来记录链表的基地址，有了它，我们就可以遍历得到整条链表。 尾结点：指针指向空地址NULL，表示这是链表上最后一个结点。 循环链表 循环链表与单链表的区别，仅在于尾结点，尾结点指针指向链表的头结点，适合处理环形结构的数据。 双向链表（在实际软件开发中更加常用） 每个结点由三部分组成，数据data，后继指针next，前驱指针prev。 特点： 占用更多存储空间，支持两个方向，更灵活。 支持O(1)找到前驱结点。在需要用到上一个结点时，用双向链表可以很容易知道上一个结点，而用单链表，需要用双指针，保留上一个结点和当前结点的位置。插入和删除当前结点，都需要用到上一个结点。 查找有序链表时，可以根据要查找的值决定往前还是往后找。 Java中，双向链表的应用：LinkedList、LinkedHashMap","head":[["link",{"rel":"alternate","hreflang":"en-us","href":"https://liz-starfield.github.io/blog/posts/code/data_structure/2.%E9%93%BE%E8%A1%A8.html"}],["meta",{"property":"og:url","content":"https://liz-starfield.github.io/blog/zh/posts/code/data_structure/2.%E9%93%BE%E8%A1%A8.html"}],["meta",{"property":"og:site_name","content":"莉芝"}],["meta",{"property":"og:title","content":"链表"}],["meta",{"property":"og:description","content":"链表 链表分类 单链表 每个结点由两部分组成，data和next。 特殊结点：头结点、尾结点 头结点：第一个结点，用来记录链表的基地址，有了它，我们就可以遍历得到整条链表。 尾结点：指针指向空地址NULL，表示这是链表上最后一个结点。 循环链表 循环链表与单链表的区别，仅在于尾结点，尾结点指针指向链表的头结点，适合处理环形结构的数据。 双向链表（在实际软件开发中更加常用） 每个结点由三部分组成，数据data，后继指针next，前驱指针prev。 特点： 占用更多存储空间，支持两个方向，更灵活。 支持O(1)找到前驱结点。在需要用到上一个结点时，用双向链表可以很容易知道上一个结点，而用单链表，需要用双指针，保留上一个结点和当前结点的位置。插入和删除当前结点，都需要用到上一个结点。 查找有序链表时，可以根据要查找的值决定往前还是往后找。 Java中，双向链表的应用：LinkedList、LinkedHashMap"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-10-16T06:02:20.000Z"}],["meta",{"property":"article:author","content":"Liz"}],["meta",{"property":"article:modified_time","content":"2024-10-16T06:02:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"链表\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-16T06:02:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Liz\\",\\"url\\":\\"https://github.com/liz-starfield\\"}]}"]]},"headers":[{"level":2,"title":"链表分类","slug":"链表分类","link":"#链表分类","children":[{"level":3,"title":"单链表","slug":"单链表","link":"#单链表","children":[]},{"level":3,"title":"循环链表","slug":"循环链表","link":"#循环链表","children":[]},{"level":3,"title":"双向链表（在实际软件开发中更加常用）","slug":"双向链表-在实际软件开发中更加常用","link":"#双向链表-在实际软件开发中更加常用","children":[]},{"level":3,"title":"双向循环链表","slug":"双向循环链表","link":"#双向循环链表","children":[]}]},{"level":2,"title":"数组vs链表","slug":"数组vs链表","link":"#数组vs链表","children":[]},{"level":2,"title":"链表应用：LRU缓存淘汰算法","slug":"链表应用-lru缓存淘汰算法","link":"#链表应用-lru缓存淘汰算法","children":[]},{"level":2,"title":"链表解题技巧","slug":"链表解题技巧","link":"#链表解题技巧","children":[{"level":3,"title":"技巧一：利用哨兵（头结点）简化实现难度，减少特殊处理","slug":"技巧一-利用哨兵-头结点-简化实现难度-减少特殊处理","link":"#技巧一-利用哨兵-头结点-简化实现难度-减少特殊处理","children":[]},{"level":3,"title":"技巧二：利用快慢指针（有时用到3个指针）","slug":"技巧二-利用快慢指针-有时用到3个指针","link":"#技巧二-利用快慢指针-有时用到3个指针","children":[]},{"level":3,"title":"技巧三：删除当前节点，但不知道上一个节点","slug":"技巧三-删除当前节点-但不知道上一个节点","link":"#技巧三-删除当前节点-但不知道上一个节点","children":[]},{"level":3,"title":"技巧四：重点留意边界条件处理","slug":"技巧四-重点留意边界条件处理","link":"#技巧四-重点留意边界条件处理","children":[]},{"level":3,"title":"技巧五：举例画图，辅助思考","slug":"技巧五-举例画图-辅助思考","link":"#技巧五-举例画图-辅助思考","children":[]},{"level":3,"title":"技巧六：多写多练，没有捷径","slug":"技巧六-多写多练-没有捷径","link":"#技巧六-多写多练-没有捷径","children":[]}]},{"level":2,"title":"链表算法题型","slug":"链表算法题型","link":"#链表算法题型","children":[{"level":3,"title":"一、需要找到单链表中指定节点的位置","slug":"一、需要找到单链表中指定节点的位置","link":"#一、需要找到单链表中指定节点的位置","children":[]},{"level":3,"title":"二、环形链表","slug":"二、环形链表","link":"#二、环形链表","children":[]},{"level":3,"title":"三、链表排序&合并链表","slug":"三、链表排序-合并链表","link":"#三、链表排序-合并链表","children":[]},{"level":3,"title":"四、翻转链表","slug":"四、翻转链表","link":"#四、翻转链表","children":[]},{"level":3,"title":"五、从尾到头打印链表（递归和非递归）","slug":"五、从尾到头打印链表-递归和非递归","link":"#五、从尾到头打印链表-递归和非递归","children":[]}]}],"git":{"createdTime":1729058540000,"updatedTime":1729058540000,"contributors":[{"name":"unknown","email":"15721607377@163.com","commits":1}]},"readingTime":{"minutes":12.19,"words":3656},"filePathRelative":"zh/posts/code/data_structure/2.链表.md","localizedDate":"2024年10月16日","excerpt":"<h1> 链表</h1>\\n<h2> 链表分类</h2>\\n<h3> 单链表</h3>\\n<p>每个结点由两部分组成，data和next。 <br>\\n特殊结点：头结点、尾结点 <br>\\n头结点：第一个结点，用来记录链表的基地址，有了它，我们就可以遍历得到整条链表。 <br>\\n尾结点：指针指向空地址NULL，表示这是链表上最后一个结点。 <br></p>\\n<h3> 循环链表</h3>\\n<p>循环链表与单链表的区别，仅在于尾结点，尾结点指针指向链表的头结点，适合处理环形结构的数据。 <br></p>\\n<h3> 双向链表（在实际软件开发中更加常用）</h3>\\n<p>每个结点由三部分组成，数据data，后继指针next，前驱指针prev。 <br>\\n特点： <br>\\n占用更多存储空间，支持两个方向，更灵活。 <br>\\n支持O(1)找到前驱结点。在需要用到上一个结点时，用双向链表可以很容易知道上一个结点，而用单链表，需要用双指针，保留上一个结点和当前结点的位置。插入和删除当前结点，都需要用到上一个结点。 <br>\\n查找有序链表时，可以根据要查找的值决定往前还是往后找。 <br>\\nJava中，双向链表的应用：LinkedList、LinkedHashMap <br></p>","autoDesc":true}');export{e as data};
