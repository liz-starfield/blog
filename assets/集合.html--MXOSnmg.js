import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as e,c as r,e as t}from"./app--2XlxX6z.js";const h="/blog/assets/集合-1-qLeelbzv.png",s="/blog/assets/集合-2-Uy_2tJeo.png",i="/blog/assets/集合-3-KLxHWKjO.png",n="/blog/assets/集合-4-ws4HYCVg.png",o="/blog/assets/集合-5-rH5LccFc.png",l="/blog/assets/集合-6-QRFJx7NL.png",E={},p=t('<h1 id="集合" tabindex="-1"><a class="header-anchor" href="#集合" aria-hidden="true">#</a> 集合</h1><ul><li><a href="#%E9%9B%86%E5%90%88">集合</a></li><li><a href="#%E4%BA%8C%E9%9B%86%E5%90%88">二、集合</a><ul><li><a href="#%E4%B8%80comparator%E4%B8%8Ecomparable%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E6%8E%92%E5%BA%8F">（一）Comparator与Comparable实现自定义类排序</a></li><li><a href="#%E4%BA%8Clist-%E5%AF%B9%E4%BB%98%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%A5%BD%E5%B8%AE--set-%E6%B3%A8%E9%87%8D%E7%8B%AC%E7%9A%84%E6%80%A7%E8%B4%A8--map-key%E6%9D%A5%E6%90%9C%E7%B4%A2%E7%9A%84%E4%B8%93%E5%AE%B6">（二）List (对付顺序的好帮⼿) 、Set (注重独⼀⽆⼆的性质) 、Map (⽤Key来搜索的专家)</a></li><li><a href="#%E4%B8%89arraylist%E5%BA%95%E5%B1%82%E6%98%AFobject%E6%95%B0%E7%BB%84linkedlist%E5%BA%95%E5%B1%82%E6%98%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%8Evector%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E8%80%8Carraylist%E4%B8%8Elinkedlist%E4%B8%8D%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">（三）ArrayList（底层是Object数组）、LinkedList（底层是双向链表）与Vector（保证线程安全，而ArrayList与LinkedList不保证线程安全）</a></li><li><a href="#%E5%9B%9Bhashmaphashtablehashsetconcurrenthashmaplinkedhashmaptreemap">（四）HashMap、Hashtable、HashSet、ConcurrentHashMap、LinkedHashMap、TreeMap</a><ul><li><a href="#1hashmap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">（1）HashMap（⾮线程安全）</a></li><li><a href="#2hashtable%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%98%AF%E5%85%A8%E8%A1%A8%E9%94%81%E6%80%A7%E8%83%BD%E5%B7%AE-%E5%9F%BA%E6%9C%AC%E8%A2%AB%E6%B7%98%E6%B1%B0">（2）HashTable（线程安全，是全表锁，性能差， 基本被淘汰）</a></li><li><a href="#3hashset%E5%BA%95%E5%B1%82%E5%B0%B1%E6%98%AF%E5%9F%BA%E4%BA%8Ehashmap%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D%E6%97%B6%E5%85%88%E7%94%A8hashcode%E5%90%8E%E7%94%A8equals">（3）HashSet（底层就是基于HashMap实现的，检查重复时，先用hashcode()，后用equals()）</a></li><li><a href="#4concurrenthashmap">（4）ConcurrentHashMap</a></li><li><a href="#5linkedhashmap">（5）LinkedHashMap</a></li><li><a href="#6treemap-%E7%BA%A2%E6%A0%91%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8F%89%E6%A0%91">（6）TreeMap： 红⿊树(⾃平衡的排序⼆叉树)</a></li></ul></li><li><a href="#%E4%BA%94copyonwritearraylist%E9%81%BF%E5%85%8D%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8">（五）CopyOnWriteArrayList避免并发修改异常</a></li><li><a href="#%E5%85%AD%E6%8A%8A%E9%9B%86%E5%90%88%E5%8C%85%E8%A3%85%E6%88%90%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84">（六）把集合包装成线程安全的</a></li></ul></li></ul><h1 id="二、集合" tabindex="-1"><a class="header-anchor" href="#二、集合" aria-hidden="true">#</a> 二、集合</h1><h2 id="一-comparator与comparable实现自定义类排序" tabindex="-1"><a class="header-anchor" href="#一-comparator与comparable实现自定义类排序" aria-hidden="true">#</a> （一）Comparator与Comparable实现自定义类排序</h2><table><thead><tr><th>Comparable接口</th><th>Comparator接口</th></tr></thead><tbody><tr><td>内部比较器</td><td>外部比较器</td></tr><tr><td>位于java.lang包下</td><td>位于java.util包下</td></tr><tr><td>public interface Comparable&lt;T&gt;{<br>public int compareTo(T o); <br>}</td><td>public interface Comparator&lt;T&gt;{ <br> int compare(T o1,T o2); <br>}</td></tr><tr><td>自定义类实现这个接口，并重写CompareTo方法，表明该类支持排序</td><td>不必修改自定义类，而要控制该类的排序，则建立一个该类的比较器并重写compare方法来进行排序</td></tr><tr><td>Collections.sort(arrayList）</td><td>Collections.sort(arrayList, new Comparator&lt;Integer&gt;() {<br> @Override <br> public int compare(Integer o1, Integer o2) { <br> return o2.compareTo(o1); <br> } <br> });</td></tr></tbody></table><p>compareto就是比较两个数据的大小关系。大于0表示前一个数据比后一个数据大（降序）， 0表示相等，小于0表示第一个数据小于第二个数据（升序） <br></p><h2 id="二-list-对付顺序的好帮手-、set-注重独一无二的性质-、map-用key来搜索的专家" tabindex="-1"><a class="header-anchor" href="#二-list-对付顺序的好帮手-、set-注重独一无二的性质-、map-用key来搜索的专家" aria-hidden="true">#</a> （二）List (对付顺序的好帮⼿) 、Set (注重独⼀⽆⼆的性质) 、Map (⽤Key来搜索的专家)</h2><p><img src="'+h+'" alt="image.png" loading="lazy"> <br><img src="'+s+'" alt="" loading="lazy"> <br></p><h2 id="三-arraylist-底层是object数组-、linkedlist-底层是双向链表-与vector-保证线程安全-而arraylist与linkedlist不保证线程安全" tabindex="-1"><a class="header-anchor" href="#三-arraylist-底层是object数组-、linkedlist-底层是双向链表-与vector-保证线程安全-而arraylist与linkedlist不保证线程安全" aria-hidden="true">#</a> （三）ArrayList（底层是Object数组）、LinkedList（底层是双向链表）与Vector（保证线程安全，而ArrayList与LinkedList不保证线程安全）</h2><p>（1）list 遍历⽅式的选择 <br> 实现了 RandomAccess 接⼝的list，优先选择普通 for 循环 ，其次 foreach。 <br> 未实现 RandomAccess 接⼝的list，优先选择iterator遍历（foreach遍历底层也是通过 iterator实现的），⼤size的数据，千万不要使⽤普通for循环。 <br> （2）ArrayList的扩容机制 <br></p><h2 id="四-hashmap、hashtable、hashset、concurrenthashmap、linkedhashmap、treemap" tabindex="-1"><a class="header-anchor" href="#四-hashmap、hashtable、hashset、concurrenthashmap、linkedhashmap、treemap" aria-hidden="true">#</a> （四）HashMap、Hashtable、HashSet、ConcurrentHashMap、LinkedHashMap、TreeMap</h2><h3 id="_1-hashmap-非线程安全" tabindex="-1"><a class="header-anchor" href="#_1-hashmap-非线程安全" aria-hidden="true">#</a> （1）HashMap（⾮线程安全）</h3><p>《Java 8系列之重新认识HashMap》 ：https://zhuanlan.zhihu.com/p/21673805 <br> ** JDK1.8之前 ** <br><img src="'+i+'" alt="image.png" loading="lazy"> <br><strong>JDK1.8 之前 HashMap 底层是 数组和链表 结合在⼀起使⽤也就是 链表散列</strong>。<br>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置 （这⾥的 n 指的是数组的⻓度），如果当前位置存在元素的话，就判断该元素与要存⼊的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。 <br> 所谓扰动函数指的就是 HashMap 的 hash ⽅法。使⽤ hash ⽅法也就是扰动函数是为了防⽌⼀些实现 ⽐较差的 hashCode() ⽅法 换句话说使⽤扰动函数之后可以减少碰撞。 <br> 所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建⼀个链表数组，数组中每⼀格就是⼀个链 表。若遇到哈希冲突，则将冲突的值加到链表中即可。 <br><strong>JDK1.8之后</strong> <br> 相⽐于之前的版本， JDK1.8之后在解决哈希冲突时有了⼤的变化，当链表⻓度⼤于阈值（默认为8） 时，将链表转化为红⿊树，以减少搜索时间。 <br> TreeMap、TreeSet以及JDK1.8之后的HashMap底层都⽤到了红⿊树。红⿊树就是为了解决⼆叉查找树 的缺陷，因为⼆叉查找树在某些情况下会退化成⼀个线性结构。 <br><strong>HashMap 的⻓度为什么是2的幂次⽅</strong> <br> 数组长度默认是16。 <br> 散列值是不能直接拿来⽤的。⽤之前还要先做对数组的⻓度取模运算，得到的余数才能⽤来要存放 的位置也就是对应的数组下标。 我们⾸先可能会想到采⽤%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则 等价于与其除数减⼀的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次⽅；）。” 并且 采⽤⼆进制位操作 &amp;，相对于%能够提⾼运算效率， 这个数组下标的计算⽅法是“ (n - 1) &amp; hash ”。（n代表数组⻓ 度）。这也就解释了 HashMap 的⻓度为什么是2的幂次⽅。 <br></p><h3 id="_2-hashtable-线程安全-是全表锁-性能差-基本被淘汰" tabindex="-1"><a class="header-anchor" href="#_2-hashtable-线程安全-是全表锁-性能差-基本被淘汰" aria-hidden="true">#</a> （2）HashTable（线程安全，是全表锁，性能差， 基本被淘汰）</h3><h3 id="_3-hashset-底层就是基于hashmap实现的-检查重复时-先用hashcode-后用equals" tabindex="-1"><a class="header-anchor" href="#_3-hashset-底层就是基于hashmap实现的-检查重复时-先用hashcode-后用equals" aria-hidden="true">#</a> （3）HashSet（底层就是基于HashMap实现的，检查重复时，先用hashcode()，后用equals()）</h3><h3 id="_4-concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#_4-concurrenthashmap" aria-hidden="true">#</a> （4）ConcurrentHashMap</h3><p>JDK1.7 <br> 底层数据结构：Segment数组结构+HashEntry链表结构+ReentrantLock <br><img src="'+n+'" alt="image.png" loading="lazy"> <br> 二维数组Segment，一个Segment中包含一个HashEntry数组，每个HashEntry又是一个链表结构 <br> 元素查询：二次hash，第一次hash定位到Segment，第二次hash定位到元素所在链表的头部 <br> 实现线程安全的⽅式：分段锁。 读不加锁，用volatile保证，写和扩容加分段锁。Segment继承了ReentrantLock，锁定操作的Segment，其他Segment不受影响。并发度为Segment的个数，可通过构造函数指定。 <br><img src="'+o+'" alt="image.png" loading="lazy"> <br> JDK1.8 <br> 底层数据结构：Node数组+链表+红黑树+synchronized <br> 实现线程安全的⽅式：到了 JDK1.8 的时候已经摒弃了Segment的 概念，⽽是直接⽤ Node 数组+链表+红⿊树的数据结构来实现，并发控制使⽤ synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） <br> synchronized只锁定当前链表或红⿊⼆叉树的⾸节点，这样只要hash不冲突，就不会产⽣并发，效率⼜提升N倍。 <br> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只 是为了兼容旧版本； <br><img src="'+l+'" alt="image.png" loading="lazy"> <br></p><h3 id="_5-linkedhashmap" tabindex="-1"><a class="header-anchor" href="#_5-linkedhashmap" aria-hidden="true">#</a> （5）LinkedHashMap</h3><p>LinkedHashMap是HashMap的一个子类， 增加了⼀条双向链表，使得上⾯的结构可以保持键值对的插⼊顺序 ，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 <br></p><h3 id="_6-treemap-红黑树-自平衡的排序二叉树" tabindex="-1"><a class="header-anchor" href="#_6-treemap-红黑树-自平衡的排序二叉树" aria-hidden="true">#</a> （6）TreeMap： 红⿊树(⾃平衡的排序⼆叉树)</h3><p>TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 <br></p><h2 id="五-copyonwritearraylist避免并发修改异常" tabindex="-1"><a class="header-anchor" href="#五-copyonwritearraylist避免并发修改异常" aria-hidden="true">#</a> （五）CopyOnWriteArrayList避免并发修改异常</h2><p>在用迭代器遍历ArrayList时，边访问边修改（插入或删除），会报并发修改异常，这是一种保护措施，建议用迭代器去遍历。 <br> 如果确实需要边访问边修改，可以使用CopyOnWriteArrayList之类的集合。 <br></p><h2 id="六-把集合包装成线程安全的" tabindex="-1"><a class="header-anchor" href="#六-把集合包装成线程安全的" aria-hidden="true">#</a> （六）把集合包装成线程安全的</h2><p>Collections.synchornizedList(list); <br> Collections.synchornizedSet(list); <br> Collections.synchornizedMap(list); <br></p>',25),d=[p];function c(b,A){return e(),r("div",null,d)}const g=a(E,[["render",c],["__file","集合.html.vue"]]);export{g as default};
