const e=JSON.parse('{"key":"v-573f8404","path":"/zh/posts/code/algorithm/3.%E6%8E%92%E5%BA%8F.html","title":"排序","lang":"zh-CN","frontmatter":{"icon":"lightbulb","description":"排序 排序算法的分析与评价 执行效率 最好情况、最坏情况、平均情况下的时间复杂度 对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。 平均复杂度分析：有序度&amp;逆序度 有序度：是数组中具有有序关系的元素对的个数。 对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是1+2+...+(n-1)=n(n-1)/2，也就是 1+2+3+4+5=15。 满有序度：我们把这种完全有序的数组的有序度叫作满有序度。 逆序度：定义正好跟有序度相反。 公式：逆序度 = 满有序度 - 有序度 我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。 拿冒泡排序的例子来说明。要排序的数组的初始状态是 4，5，6，3， 2，1 ，其中，有序元素对有 (4，5) (4，6)(5，6)，所以有序度是 3。n=6，所以排序完成之后终态的满有序度为 n(n-1)/2=15。 冒泡排序包含两个操作原子，比较和交换**。每交换一次，有序度就加 1。不管算法怎么改 进，交换次数总是确定的，即为逆序度，也就是n*(n-1)/2减去初始有序度。 此例中就是 15– 3=12，要进行 12 次交换操作。 对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行 n*(n-1)/2 次交换。最好情况下，初始状态的有序度是 n*(n-1)/2，就不需要进行交换。我们可以取个中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。 换句话说，平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n)，所以平均情况下的时间复杂度就是 O(n)。 这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，毕竟概率论的定量分析太复杂，不太好用。","head":[["link",{"rel":"alternate","hreflang":"en-us","href":"https://liz-starfield.github.io/blog/posts/code/algorithm/3.%E6%8E%92%E5%BA%8F.html"}],["meta",{"property":"og:url","content":"https://liz-starfield.github.io/blog/zh/posts/code/algorithm/3.%E6%8E%92%E5%BA%8F.html"}],["meta",{"property":"og:site_name","content":"莉芝"}],["meta",{"property":"og:title","content":"排序"}],["meta",{"property":"og:description","content":"排序 排序算法的分析与评价 执行效率 最好情况、最坏情况、平均情况下的时间复杂度 对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。 平均复杂度分析：有序度&amp;逆序度 有序度：是数组中具有有序关系的元素对的个数。 对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是1+2+...+(n-1)=n(n-1)/2，也就是 1+2+3+4+5=15。 满有序度：我们把这种完全有序的数组的有序度叫作满有序度。 逆序度：定义正好跟有序度相反。 公式：逆序度 = 满有序度 - 有序度 我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。 拿冒泡排序的例子来说明。要排序的数组的初始状态是 4，5，6，3， 2，1 ，其中，有序元素对有 (4，5) (4，6)(5，6)，所以有序度是 3。n=6，所以排序完成之后终态的满有序度为 n(n-1)/2=15。 冒泡排序包含两个操作原子，比较和交换**。每交换一次，有序度就加 1。不管算法怎么改 进，交换次数总是确定的，即为逆序度，也就是n*(n-1)/2减去初始有序度。 此例中就是 15– 3=12，要进行 12 次交换操作。 对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行 n*(n-1)/2 次交换。最好情况下，初始状态的有序度是 n*(n-1)/2，就不需要进行交换。我们可以取个中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。 换句话说，平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n)，所以平均情况下的时间复杂度就是 O(n)。 这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，毕竟概率论的定量分析太复杂，不太好用。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-10-16T06:02:20.000Z"}],["meta",{"property":"article:author","content":"Liz"}],["meta",{"property":"article:modified_time","content":"2024-10-16T06:02:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"排序\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-16T06:02:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Liz\\",\\"url\\":\\"https://github.com/liz-starfield\\"}]}"]]},"headers":[{"level":2,"title":"执行效率","slug":"执行效率","link":"#执行效率","children":[{"level":3,"title":"最好情况、最坏情况、平均情况下的时间复杂度","slug":"最好情况、最坏情况、平均情况下的时间复杂度","link":"#最好情况、最坏情况、平均情况下的时间复杂度","children":[]},{"level":3,"title":"时间复杂度的系数、常数、低阶","slug":"时间复杂度的系数、常数、低阶","link":"#时间复杂度的系数、常数、低阶","children":[]},{"level":3,"title":"比较次数和交换（或移动）次数","slug":"比较次数和交换-或移动-次数","link":"#比较次数和交换-或移动-次数","children":[]}]},{"level":2,"title":"内存消耗","slug":"内存消耗","link":"#内存消耗","children":[]},{"level":2,"title":"稳定性","slug":"稳定性","link":"#稳定性","children":[]},{"level":2,"title":"为什么快速排序的性能要比堆排序好？","slug":"为什么快速排序的性能要比堆排序好","link":"#为什么快速排序的性能要比堆排序好","children":[]},{"level":2,"title":"在实际的软件开发里，为什么更倾向于使用插入排序算法而不是冒泡排序算法呢？","slug":"在实际的软件开发里-为什么更倾向于使用插入排序算法而不是冒泡排序算法呢","link":"#在实际的软件开发里-为什么更倾向于使用插入排序算法而不是冒泡排序算法呢","children":[]},{"level":2,"title":"快排（快速排序，Quick Sort）","slug":"快排-快速排序-quick-sort","link":"#快排-快速排序-quick-sort","children":[{"level":3,"title":"如何优化快排","slug":"如何优化快排","link":"#如何优化快排","children":[]},{"level":3,"title":"在 O(n) 的时间复杂度内查找第 K 大元素","slug":"在-o-n-的时间复杂度内查找第-k-大元素","link":"#在-o-n-的时间复杂度内查找第-k-大元素","children":[]}]},{"level":2,"title":"归并排序（Merge Sort）","slug":"归并排序-merge-sort","link":"#归并排序-merge-sort","children":[{"level":3,"title":"归并排序和分治的应用：统计逆序对个数","slug":"归并排序和分治的应用-统计逆序对个数","link":"#归并排序和分治的应用-统计逆序对个数","children":[]}]},{"level":2,"title":"堆排序（Heap Sort）","slug":"堆排序-heap-sort","link":"#堆排序-heap-sort","children":[]},{"level":2,"title":"冒泡排序（Bubble Sort）","slug":"冒泡排序-bubble-sort","link":"#冒泡排序-bubble-sort","children":[]},{"level":2,"title":"选择排序（Selection Sort）","slug":"选择排序-selection-sort","link":"#选择排序-selection-sort","children":[]},{"level":2,"title":"插入排序（Insertion Sort）","slug":"插入排序-insertion-sort","link":"#插入排序-insertion-sort","children":[]},{"level":2,"title":"希尔排序（Shell Sort）插入排序的优化","slug":"希尔排序-shell-sort-插入排序的优化","link":"#希尔排序-shell-sort-插入排序的优化","children":[]},{"level":2,"title":"桶排序（Bucket Sort）","slug":"桶排序-bucket-sort","link":"#桶排序-bucket-sort","children":[{"level":3,"title":"复杂度分析","slug":"复杂度分析","link":"#复杂度分析","children":[]},{"level":3,"title":"适用场景","slug":"适用场景","link":"#适用场景","children":[]},{"level":3,"title":"应用：海量数据排序（无法将数据全部加载到内存中）","slug":"应用-海量数据排序-无法将数据全部加载到内存中","link":"#应用-海量数据排序-无法将数据全部加载到内存中","children":[]}]},{"level":2,"title":"计数排序（Counting Sort）桶排序的一种特殊情况","slug":"计数排序-counting-sort-桶排序的一种特殊情况","link":"#计数排序-counting-sort-桶排序的一种特殊情况","children":[{"level":3,"title":"复杂度分析","slug":"复杂度分析-1","link":"#复杂度分析-1","children":[]},{"level":3,"title":"适用场景","slug":"适用场景-1","link":"#适用场景-1","children":[]},{"level":3,"title":"应用：如何根据年龄给100万用户排序","slug":"应用-如何根据年龄给100万用户排序","link":"#应用-如何根据年龄给100万用户排序","children":[]}]},{"level":2,"title":"基数排序（Radix Sort）按位排序","slug":"基数排序-radix-sort-按位排序","link":"#基数排序-radix-sort-按位排序","children":[{"level":3,"title":"不等长的处理：补齐到相同长度","slug":"不等长的处理-补齐到相同长度","link":"#不等长的处理-补齐到相同长度","children":[]},{"level":3,"title":"时间复杂度分析","slug":"时间复杂度分析","link":"#时间复杂度分析","children":[]},{"level":3,"title":"适用场景","slug":"适用场景-2","link":"#适用场景-2","children":[]},{"level":3,"title":"应用：10万个手机号码排序","slug":"应用-10万个手机号码排序","link":"#应用-10万个手机号码排序","children":[]}]}],"git":{"createdTime":1729058540000,"updatedTime":1729058540000,"contributors":[{"name":"unknown","email":"15721607377@163.com","commits":1}]},"readingTime":{"minutes":23.65,"words":7094},"filePathRelative":"zh/posts/code/algorithm/3.排序.md","localizedDate":"2024年10月16日","excerpt":"<h1> 排序</h1>\\n<h1> 排序算法的分析与评价</h1>\\n<h2> 执行效率</h2>\\n<h3> 最好情况、最坏情况、平均情况下的时间复杂度</h3>\\n<p>对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。   <br></p>\\n<h4> 平均复杂度分析：有序度&amp;逆序度</h4>\\n<p><strong>有序度：<em><em>是数组中具有有序关系的元素对的个数。 <br>\\n对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是1+2+...+(n-1)=n</em>(n-1)/2，也就是 1+2+3+4+5=15。 <br>\\n<strong>满有序度</strong>：我们把这种完全有序的数组的有序度叫作满有序度。   <br>\\n <br>\\n<strong>逆序度</strong>：定义正好跟有序度相反。 <br>\\n <br>\\n<strong>公式</strong>：<strong>逆序度 = 满有序度 - 有序度</strong> <br>\\n我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。  <br>\\n拿冒泡排序的例子来说明。要排序的数组的初始状态是 4，5，6，3， 2，1 ，其中，有序元素对有 (4，5) (4，6)(5，6)，所以有序度是 3。n=6，所以排序完成之后终态的满有序度为 n</em>(n-1)/2=15。   <br>\\n <br>\\n冒泡排序包含两个操作原子，<strong>比较</strong>和</strong>交换**。每交换一次，有序度就加 1。不管算法怎么改 进，<strong>交换次数总是确定的，即为逆序度</strong>，也就是n*(n-1)/2减去初始有序度。 <br>\\n此例中就是 15– 3=12，要进行 12 次交换操作。 对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行 n*(n-1)/2 次交换。最好情况下，初始状态的有序度是 n*(n-1)/2，就不需要进行交换。我们可以取个中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。 换句话说，平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n)，所以平均情况下的时间复杂度就是 O(n)。  <br>\\n这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，毕竟概率论的定量分析太复杂，不太好用。 <br></p>","autoDesc":true}');export{e as data};
