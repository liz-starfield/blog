---
icon: lightbulb
---
# 队列
（1）队列也是一种“操作受限”的线性表，只支持两种基本操作：入队（队尾）和出队 （队头）  <br/>
（2）顺序队列和链式队列 <br/>
顺序队列：用数组实现 <br/>
针对队尾满了，对头还有很多空位，解决方案：循环队列；一旦队尾满了，整体移到前面（不如循环队列） <br/>
链式队列：用链表实现 <br/>
（3）循环队列 <br/>
 要想写出没有 bug 的循环队列实现代码，关键要确定好队空和队满的判定条件。 <br/>
队满判定条件：head=tail <br/>
队满判定条件：(tail+1)%n=head <br/>
（4）阻塞队列与并发队列 <br/>
 阻塞队列、并发队列，底层都还是队列这种数 据结构，只不过在之上附加了很多其他功能。阻塞队列就是入队、出队操作可以阻塞，并发 队列就是队列的操作多线程安全。   <br/>
（5）应用 <br/>
算法中应用：广度优先搜索 <br/>

 队列的应用非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。 它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。   <br/>
队列在线程池等有限资源池中的应用 <br/>
 CPU 资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换，处理性能下降。所以，线程池的大小一般都是综合考 虑要处理任务的特点和硬件环境，来事先设置的。 当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线 程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？ <br/>

 我们一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞 的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。那如何存储排队 的请求呢？ 我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储 排队请求。我们前面说过，队列有基于链表和基于数组这两种实现方式。这两种实现方式对 于排队请求又有什么区别呢？ 基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但 是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏 感的系统，基于链表实现的无限排队的线程池是不合适的。 而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的 请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就 相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的 请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。 除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中， 用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资 源时，基本上都可以通过“队列”这种数据结构来实现请求排队。     <br/>
## 双端队列Deque
 基本实现 可以利⽤⼀个双链表 队列的头尾两端能在 O(1) 的时间内进⾏数据的查看、添加和删除   <br/>
 常⽤场景：实现⼀个⻓度动态变化的窗⼝或者连续区间   <br/>
## 单调队列
元素按从小到大或从大到小排列，具有单调性 <br/>
